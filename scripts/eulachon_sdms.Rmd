---
title: "Eulachon eDNA SDMs"
author: "Owen R. Liu"
date: "2024-02-09"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
options(dplyr.summarise.inform=FALSE)
library(tidyverse)
library(here)
library(tictoc)
library(sf)
library(viridis)
library(ggsci)
library(cowplot)
library(rnaturalearth)
library(marmap)
library(RANN)
library(contoureR)
library(sdmTMB)
library(nngeo)
library(contoureR)
library(corrplot)
```

# Purpose

Build species distribution models in `sdmTMB` for eulachon, based on spatiotemporal data on eDNA for eulachon (*Thaleichthys pacificus*). The data are structured in three dimensions (latitude, longitude, depth), or four including year, and so we want to build a flexible set of models that can take advantage of this dimensionality of the data to create high-resolution predictions.

We will use environmental covariates to constrain our predictions, based on temperature, salinity, and bottom depth, as well as biological productivity variables. In spatiotemporal models, though, we also need to decide how to guide the model to partition variation across different spatial and depth fields (i.e., the spatially autocorrelated parts of the model that are estimated in parallel to the fitted covariates). To explore these options, we decided to try models with different combinations of spatial fields and intercepts:

Spatial field options to try: 

*   One common spatial field across all data
*   spatial field by depth
*   spatial field by year
*   spatial field by depth and year

Intercepts options to try

*   single intercept
*   random intercept by depth category
*   random intercept by year
*   random intercept by depth and year

Combinations of spatial fields and intercepts gives us 16 models to consider. Some of these models will certainly break and/or not converge, particularly the more complex versions.

# Pre-processing

Import eDNA and covariate data, designate offsets, and build prediction grid. Note that cleaning and joining of the standards and unknown samples has been done in other scripts---one to process the 2019 data, one for 2021, and one to join them. If desired, you can re-run those here, but they are not evaluated out for now to save time.

```{r,eval=F,warning=F,message=F}
rmarkdown::render(here::here('scripts','process 2019 eulachon data.Rmd'),quiet=TRUE)
rmarkdown::render(here::here('scripts','process 2021 eulachon data.Rmd'),quiet=TRUE)
source(here::here('scripts','join_eulachon_qPCR_data.R'))

rm(list=ls())
```


## Import Data

Spatial coordinate reference system we will use for thesse analyses:

```{r}
pred.crs <- terra::rast(here('data','raster_grid_blake','fivekm_grid.tif')) %>% st_crs()
```


Load in our cleaned and joined eDNA data.

```{r}
# qPCR standards
d <- read_rds(here('data','qPCR',"eulachon qPCR 2019 and 2021 standards clean.rds")) %>% 
  mutate(Ct=replace_na(Ct,0))# delta-models in sdmTMB need this

# field samples
d_obs <- read_rds(here('data','qPCR','eulachon qPCR 2019 and 2021 samples clean.rds')) %>% 
  mutate(Ct=replace_na(Ct,0)) %>% # delta-models in sdmTMB need this
  mutate(utm.lon.km=utm.lon.m/1000,
         utm.lat.km=utm.lat.m/1000)

# field samples, filtered such that we are only including depth categories 0 (surface), 50m, and 150m
d_obs_filt <- d_obs %>% filter(depth_cat %in% c(0,50,150))

d_obs_sf <- d_obs_filt %>% st_as_sf(coords=c('utm.lon.m','utm.lat.m'),crs=pred.crs)
```

## Prediction Grid

This is the 5km grid that we will use to project the models for mapping.

```{r}
## Prediction
# MAKE GRID
grid.pred <- read_rds(here('data','prediction_grid_5km_sdmTMB.rds')) %>% 
  #make bottom depth positive
  mutate(bathy.bottom.depth=-bathy.bottom.depth)

# add depth categories
grid.pred0 <- grid.pred %>% mutate(depth_cat=0)
grid.pred50 <- grid.pred %>% filter(bathy.bottom.depth >= 50) %>% mutate(depth_cat=50)
grid.pred150 <- grid.pred %>% filter(bathy.bottom.depth >= 100) %>% mutate(depth_cat=150)

grid.predz <- bind_rows(grid.pred0,grid.pred50,grid.pred150) %>% 
  mutate(depth_fct=as.factor(depth_cat))

#background map
coast <- ne_states(country='United States of America',returnclass = 'sf') %>% 
  filter(name %in% c('California','Oregon','Washington','Nevada')) %>%
  st_transform(crs = pred.crs)
```

## Covariate data

Bathymetry/bottom depth was already attached to the samples during pre-processing.

### Krill/Euphausiid data

These data on the relative abundance of krill come from Beth Phillips, and are organized in the script `krill_nasc_matching`. As with the raw data cleaning above, we do not evaluate this chunk here and just use the output; but the user can run it if they wish. Be warned that it will take awhile to run.

```{r,eval=F}
rmarkdown::render(here::here('scripts','krill_nasc_matching.Rmd'),quiet=TRUE)
```


```{r}
# Load
edna_krill_metrics <- read_rds(here('model output','edna_krill_metrics.rds')) %>% 
  filter(depth_cat %in% c(0,50,150))
  
d_obs_filt <- d_obs_filt %>% bind_cols(edna_krill_metrics %>% dplyr::select(k1:k5))
```

## Center Covariates

```{r}
#center and scale covariates
d_obs_filt <- d_obs_filt %>% 
  # make bottom depth positive
  mutate(bathy.bottom.depth=-bathy.bottom.depth) %>% 
  # center and scale covariates
  mutate(across(c(bathy.bottom.depth,k1,k2,k3,k4,k5),list(norm=function(x) as.numeric(scale(x)))))
```

## Designate Offsets

While we are primarily interested in eulachon DNA concentration over space, time, and depth, we do not directly measure this concentration with our observations. Rather, we have replicate qPCR observations assocated with a water sample taken from a Niskin bottle and we have to account for the various modifications that have occurred during water sampling and processing. As part of this, we have a series of offsets that modify the true DNA concentration to affect what we observed in the qPCR. These [offsets](https://pbs-assess.github.io/sdmTMB/articles/model-description.html#offset-terms) will go into the model as log-transformed variables (because we will use a log link), and are scaling factors without estimated coefficients.

We are primarily concerned with two offsets: one for the volume filtered out of each 2.5L Niskin bottle for each sample. Second, some samples were inhibited in PCR, and were diluted to eliminate this inhibition.

```{r}
d_obs_filt <- d_obs_filt %>% 
  # volume offset
  mutate(ln_volume=log(volume),
  # dilution/inhibition offset       
         ln_dilution=log(dilution))

# count up the distribution of these offsets
d_obs_filt %>% 
  count(volume,ln_volume)
d_obs_filt %>% 
  count(dilution,ln_dilution)

# we can add the offsets together to create just one offset vectors since they are additive in log space
d_obs_filt <- d_obs_filt %>% 
  mutate(offset_vol_dil=ln_volume+ln_dilution)
```

## INLA Mesh

Create the mesh that will be the basis of our estimation---based on the spatial distribution of our sample data, the mesh is created in order to facilitate efficient processing and estimatino of the model in sdmTMB. Instead of calculating enormous covariance matrices in model fitting, we can drastically reduce computation time by using the mesh.

```{r}
# as of 2/13/24, these were the mesh options setup that Ole is using for hake
# locs <- d_obs_filt %>%
#   distinct(year,station,utm.lon.km,utm.lat.km) %>% 
#   st_as_sf(coords=c("utm.lon.km", "utm.lat.km"))
# domain <-fmesher::fm_nonconvex_hull(locs,
#                               concave = -0.025,
#                               convex = -0.025)
# 
# inla_mesh <- fmesher::fm_mesh_2d_inla(
#   #loc=locs[,c("utm.lon","utm.lat")],
#   loc.domain = domain, # coordinates
#   boundary=domain,
#   max.edge = c(40, 1000), # max triangle edge length; inner and outer meshes
#   offset = c(30, 80),  # inner and outer border widths
#   #max.n.strict=100,#,
#   cutoff = 64 , # minimum triangle edge length
#   min.angle=20
# )

locs <- d_obs_filt %>%
  distinct(year,station,utm.lon.km,utm.lat.km) %>% 
  st_as_sf(coords=c("utm.lon.km", "utm.lat.km"))

max.edge = diff(range(st_coordinates(locs)[,1]))/5
bound.outer = diff(range(st_coordinates(locs)[,1]))/3

domain <-fmesher::fm_nonconvex_hull(locs,
                              concave = -0.025,
                              convex = -0.025)

inla_mesh <- fmesher::fm_mesh_2d_inla(
  #loc=locs[,c("utm.lon","utm.lat")],
  loc.domain = domain, # coordinates
  boundary=domain,
  max.edge = c(max.edge,max.edge*10), # max triangle edge length; inner and outer meshes
  offset = c(max.edge, bound.outer),  # inner and outer border widths
  #max.n.strict=100,#,
  # min.angle=20,
  cutoff = max.edge/2 # minimum triangle edge length
)

mesh <- make_mesh(d_obs_filt, c("utm.lon.km", "utm.lat.km"), mesh = inla_mesh)
mesh2 <- make_mesh(d_obs_filt, c("utm.lon.km", "utm.lat.km"), cutoff=20)
mesh$mesh$n
mesh2$mesh$n
plot(mesh)
plot(mesh2)
```

Now we are ready to start fitting models

# Fit Models

All models will include a spatial field of some flavor, as well as all of the environmental covariates and offsets. They will vary in the specification of the spatial field(s) and the types of offsets/intercepts we impose.

Spatial field options to try: 

*   One common spatial field across all data
*   spatial field by depth
*   spatial field by year
*   spatial field by depth and year

Intercepts options to try

*   single intercept
*   random intercept by depth category
*   random intercept by year
*   random intercept by depth and year

We will do this one at a time, increasing slowly in complexity.

## Common Spatial Field

First, a model with just one common spatial field, and a single intercept.

```{r}
tic("Fitting model: ")
f1 <- sdmTMB(
  Ct ~ 1+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3),
  data = d_obs_filt,
  mesh = mesh2,
  offset= "offset_vol_dil",
  spatial="on",
  spatiotemporal = "off",
  time=NULL,
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 13525.31
```

One spatial field, random intercept by depth category

```{r}
tic("Fitting model: ")
d_obs_filt$depth_cat <- factor(d_obs_filt$depth_cat)
f2 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+(1|depth_cat),
  data = d_obs_filt,
  mesh = mesh2,
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 13246.63
```

One spatial field, random intercept by year

```{r}
tic("Fitting model: ")
d_obs_filt$yr_fct <- as.factor(d_obs_filt$year)
f3 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 13310.52
```

One spatial field, random intercept by year and depth category

```{r}
tic("Fitting model: ")
f4 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|depth_cat)+(1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 13214.31
```

## Spatial Field by Depth

Spatial field by depth category, single intercept.

```{r}
m <- model.matrix(Ct ~ as.factor(depth_cat), data = d_obs_filt)
d_obs_filt$d1 <- m[,1]
d_obs_filt$d2 <- m[,2]
d_obs_filt$d3 <- m[,3]
```


```{r}
tic("Fitting model: ")
f5 <- sdmTMB(
  Ct ~ 1+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3),
  data = d_obs_filt,
  mesh = mesh,
  spatial_varying= ~d1+d2+d3,
  spatiotemporal="off",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 12001.99
# lots of warnings- seems to have trouble partitioning between spatial and depth
```

Spatial field by depth category, random intercept by depth category. This one feels weird

```{r}
tic("Fitting model: ")
f6 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|depth_cat),
  data = d_obs_filt,
  mesh = mesh,
  spatial_varying= ~d1+d2+d3,
  spatiotemporal="off",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 12014.63; similar issues as f5 above
```

Spatial field by depth category, random intercept by year.

```{r}
tic("Fitting model: ")
f7 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  spatial_varying= ~d1+d2+d3,
  spatiotemporal="off",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 11932.48, similar issues as the two previous models
```

Spatial field by depth category, random intercept by depth and year

```{r}
tic("Fitting model: ")
f8 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|depth_cat)+(1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  spatial_varying= ~d1+d2+d3,
  spatiotemporal="off",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
# AIC 11932.79, but same issues as above
```

## Spatial Field by Year

Spatial field by year, single intercept.

```{r}
tic("Fitting model: ")
f9 <- sdmTMB(
  Ct ~ 1+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3),
  data = d_obs_filt,
  mesh = mesh,
  time="year",
  spatiotemporal="IID",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 
```

Spatial field by year, random intercept by depth category.

```{r}
tic("Fitting model: ")
f10 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|depth_cat),
  data = d_obs_filt,
  mesh = mesh,
  time="year",
  spatiotemporal="IID",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 
```

Spatial field by year, random intercept by year.

```{r}
tic("Fitting model: ")
f11 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  time="year",
  spatiotemporal="IID",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
#AIC 
```

Spatial field by year, random intercept by depth and year

```{r}
tic("Fitting model: ")
f12 <- sdmTMB(
  Ct ~ 0+s(bathy.bottom.depth_norm,k=3)+s(k5_norm,k=3)+ (1|depth_cat)+(1|yr_fct),
  data = d_obs_filt,
  mesh = mesh,
  time="year",
  spatiotemporal="IID",
  spatial="on",
  family = stdcurve(),
  control = sdmTMBcontrol(stdcurve_df = d)
)
toc()
```

Where we're at so far: models 1 through 4 converged with no issues, and relatively quickly. Models 5-8 seemingly had difficulty apportioning variance between the basic spatial field and the spatially varying coefficients for depth. They converged, but with significant warnings (see,e.g., `sanity(f8)`). Models 9-12 did not appropriately converge.

# Conditional Effects

We can look at the estimated effects of bottom depth and krill on our estimates of eulachon eDNA, conditional on all other variable being held at their means. For now, we use models 1-4 for this.

## Bottom Depth

```{r}
depth.cond <- purrr::map2_df(list(f1,f2,f3,f4),c("f1","f2","f3","f4"),function(m,n){
  depths <- tibble(
    bathy.bottom.depth_norm= seq(min(d_obs_filt$bathy.bottom.depth_norm),max(d_obs_filt$bathy.bottom.depth_norm),length.out=100),
    year=2019, yr_fct=as.factor(2019),depth_cat=as.factor(50),
    k5_norm=mean(d_obs_filt$k5_norm))
  pr <- predict(m,newdata=depths,se_fit=TRUE,re_form=NA)
  pr %>% mutate(model=n)
})

depth.cond.p <- depth.cond %>%  
  mutate(bathy.bottom.depth=bathy.bottom.depth_norm*sd(d_obs_filt$bathy.bottom.depth)+mean(d_obs_filt$bathy.bottom.depth)) %>% 
  ggplot(aes(bathy.bottom.depth, exp(est),
  ymin = exp(est - 1.96 * est_se),
  ymax = exp(est + 1.96 * est_se),
  fill=model
)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  scale_x_continuous() +
  coord_cartesian(expand = F) +
  labs(x = "Depth (m)", y = "eDNA conc.")
depth.cond.p
```

## Krill

```{r}
krill.cond <- purrr::map2_df(list(f1,f2,f3,f4),c("f1","f2","f3","f4"),function(m,n){
  depths <- tibble(
    bathy.bottom.depth_norm= mean(d_obs_filt$bathy.bottom.depth_norm),
    year=2019, yr_fct=as.factor(2019),depth_cat=as.factor(50),
    k5_norm=seq(min(d_obs_filt$k5_norm),max(d_obs_filt$k5_norm),length.out=100))
  pr <- predict(m,newdata=depths,se_fit=TRUE,re_form=NA)
  pr %>% mutate(model=n)
})

krill.cond.p <- krill.cond %>%  
  mutate(k5=k5_norm*sd(d_obs_filt$k5)+mean(d_obs_filt$k5)) %>% 
  ggplot(aes(k5, exp(est),
  ymin = exp(est - 1.96 * est_se),
  ymax = exp(est + 1.96 * est_se),
  fill=model
)) +
  geom_line() +
  geom_ribbon(alpha = 0.4) +
  scale_x_continuous() +
  coord_cartesian(expand = F) +
  labs(x = "Normalized Krill", y = "eDNA conc.")
krill.cond.p
```
```

